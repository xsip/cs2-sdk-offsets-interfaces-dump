// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif





namespace CS2 {
	namespace modellib {
		class VPhysXBodyPart_t;
		class PhysShapeMarkup_t;
		class VPhysXConstraint2_t;
		class VPhysXJoint_t;
		class VPhysXCollisionAttributes_t;
	}
	namespace physicslib {
		class PhysFeModelDesc_t;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace modellib {
		class VPhysXAggregateData_t  {
		public:
			uint16_t m_nFlags; // 0x0 | Schema_Builtin | Size: 0x2
			uint16_t m_nRefCounter; // 0x2 | Schema_Builtin | Size: 0x2
			S2_PAD(0x4);
			GlobalTypes::CUtlVector< uint32 > m_bonesHash; // 0x8 | Schema_Atomic | Size: 0x18
			// char  m_bonesHash[0x18]; // 0x8 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< GlobalTypes::CUtlString > m_boneNames; // 0x20 | Schema_Atomic | Size: 0x18
			// char  m_boneNames[0x18]; // 0x20 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< uint16 > m_indexNames; // 0x38 | Schema_Atomic | Size: 0x18
			// char  m_indexNames[0x18]; // 0x38 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< uint16 > m_indexHash; // 0x50 | Schema_Atomic | Size: 0x18
			// char  m_indexHash[0x18]; // 0x50 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< GlobalTypes::matrix3x4a_t > m_bindPose; // 0x68 | Schema_Atomic | Size: 0x18
			// char  m_bindPose[0x18]; // 0x68 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< modellib::VPhysXBodyPart_t > m_parts; // 0x80 | Schema_Atomic | Size: 0x18
			// char  m_parts[0x18]; // 0x80 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< modellib::PhysShapeMarkup_t > m_shapeMarkups; // 0x98 | Schema_Atomic | Size: 0x18
			// char  m_shapeMarkups[0x18]; // 0x98 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< modellib::VPhysXConstraint2_t > m_constraints2; // 0xb0 | Schema_Atomic | Size: 0x18
			// char  m_constraints2[0x18]; // 0xb0 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< modellib::VPhysXJoint_t > m_joints; // 0xc8 | Schema_Atomic | Size: 0x18
			// char  m_joints[0x18]; // 0xc8 | Schema_Atomic | Size: 0x18
			physicslib::PhysFeModelDesc_t* m_pFeModel; // 0xe0 | Schema_Ptr | Size: 0x8
			GlobalTypes::CUtlVector< uint16 > m_boneParents; // 0xe8 | Schema_Atomic | Size: 0x18
			// char  m_boneParents[0x18]; // 0xe8 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< uint32 > m_surfacePropertyHashes; // 0x100 | Schema_Atomic | Size: 0x18
			// char  m_surfacePropertyHashes[0x18]; // 0x100 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< modellib::VPhysXCollisionAttributes_t > m_collisionAttributes; // 0x118 | Schema_Atomic | Size: 0x18
			// char  m_collisionAttributes[0x18]; // 0x118 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< GlobalTypes::CUtlString > m_debugPartNames; // 0x130 | Schema_Atomic | Size: 0x18
			// char  m_debugPartNames[0x18]; // 0x130 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlString m_embeddedKeyvalues; // 0x148 | Schema_Atomic | Size: 0x8
		};
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_nFlags) == 0x0, "m_nFlags in VPhysXAggregateData_t should be at offset 0x0");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_nRefCounter) == 0x2, "m_nRefCounter in VPhysXAggregateData_t should be at offset 0x2");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_bonesHash) == 0x8, "m_bonesHash in VPhysXAggregateData_t should be at offset 0x8");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_boneNames) == 0x20, "m_boneNames in VPhysXAggregateData_t should be at offset 0x20");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_indexNames) == 0x38, "m_indexNames in VPhysXAggregateData_t should be at offset 0x38");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_indexHash) == 0x50, "m_indexHash in VPhysXAggregateData_t should be at offset 0x50");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_bindPose) == 0x68, "m_bindPose in VPhysXAggregateData_t should be at offset 0x68");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_parts) == 0x80, "m_parts in VPhysXAggregateData_t should be at offset 0x80");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_shapeMarkups) == 0x98, "m_shapeMarkups in VPhysXAggregateData_t should be at offset 0x98");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_constraints2) == 0xB0, "m_constraints2 in VPhysXAggregateData_t should be at offset 0xB0");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_joints) == 0xC8, "m_joints in VPhysXAggregateData_t should be at offset 0xC8");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_pFeModel) == 0xE0, "m_pFeModel in VPhysXAggregateData_t should be at offset 0xE0");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_boneParents) == 0xE8, "m_boneParents in VPhysXAggregateData_t should be at offset 0xE8");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_surfacePropertyHashes) == 0x100, "m_surfacePropertyHashes in VPhysXAggregateData_t should be at offset 0x100");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_collisionAttributes) == 0x118, "m_collisionAttributes in VPhysXAggregateData_t should be at offset 0x118");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_debugPartNames) == 0x130, "m_debugPartNames in VPhysXAggregateData_t should be at offset 0x130");
		static_assert(offsetof(CS2::modellib::VPhysXAggregateData_t, m_embeddedKeyvalues) == 0x148, "m_embeddedKeyvalues in VPhysXAggregateData_t should be at offset 0x148");
		static_assert(sizeof(CS2::modellib::VPhysXAggregateData_t) == 0x150, "VPhysXAggregateData_t size should be 0x150");
	}
}
