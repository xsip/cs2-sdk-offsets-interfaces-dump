// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/entity2/CEntityInstance.hpp>
#include <SDK/client/CNetworkTransmitComponent.hpp>
#include <SDK/entity2/GameTick_t.hpp>
#include <SDK/client/TakeDamageFlags_t.hpp>
#include <SDK/client/EntityPlatformTypes_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/client/CNetworkVelocityVector.hpp>
#include <SDK/client/MoveCollide_t.hpp>
#include <SDK/client/MoveType_t.hpp>
#include <SDK/particleslib/CParticleProperty.hpp>
#include <SDK/client/BloodType.hpp>



namespace CS2 {
	namespace client {
		class CBodyComponent;
		class CGameSceneNode;
		class CRenderComponent;
		class CCollisionProperty;
		class thinkfunc_t;
	}
}


using namespace GlobalTypes;
namespace CS2 {
	namespace client {
		class C_BaseEntity : public CS2::entity2::CEntityInstance {
		public:
			client::CBodyComponent* m_CBodyComponent; // 0x38 | Schema_Ptr | Size: 0x8
			client::CNetworkTransmitComponent m_NetworkTransmitComponent; // 0x40 | Schema_DeclaredClass | Size: 0x1c8
			S2_PAD(0x120);
			entity2::GameTick_t m_nLastThinkTick; // 0x328 | Schema_DeclaredClass | Size: 0x4
			S2_PAD(0x4);
			client::CGameSceneNode* m_pGameSceneNode; // 0x330 | Schema_Ptr | Size: 0x8
			client::CRenderComponent* m_pRenderComponent; // 0x338 | Schema_Ptr | Size: 0x8
			client::CCollisionProperty* m_pCollision; // 0x340 | Schema_Ptr | Size: 0x8
			int32_t m_iMaxHealth; // 0x348 | Schema_Builtin | Size: 0x4
			int32_t m_iHealth; // 0x34c | Schema_Builtin | Size: 0x4
			float32 m_flDamageAccumulator; // 0x350 | Schema_Builtin | Size: 0x4
			uint8_t m_lifeState; // 0x354 | Schema_Builtin | Size: 0x1
			bool m_bTakesDamage; // 0x355 | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			client::TakeDamageFlags_t m_nTakeDamageFlags; // 0x358 | Schema_DeclaredEnum | Size: 0x8
			client::EntityPlatformTypes_t m_nPlatformType; // 0x360 | Schema_DeclaredEnum | Size: 0x1
			uint8_t m_ubInterpolationFrame; // 0x361 | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			GlobalTypes::CHandle< client::C_BaseEntity > m_hSceneObjectController; // 0x364 | Schema_Atomic | Size: 0x4
			// char  m_hSceneObjectController[0x4]; // 0x364 | Schema_Atomic | Size: 0x4
			int32_t m_nNoInterpolationTick; // 0x368 | Schema_Builtin | Size: 0x4
			int32_t m_nVisibilityNoInterpolationTick; // 0x36c | Schema_Builtin | Size: 0x4
			float32 m_flProxyRandomValue; // 0x370 | Schema_Builtin | Size: 0x4
			int32_t m_iEFlags; // 0x374 | Schema_Builtin | Size: 0x4
			uint8_t m_nWaterType; // 0x378 | Schema_Builtin | Size: 0x1
			bool m_bInterpolateEvenWithNoModel; // 0x379 | Schema_Builtin | Size: 0x1
			bool m_bPredictionEligible; // 0x37a | Schema_Builtin | Size: 0x1
			bool m_bApplyLayerMatchIDToModel; // 0x37b | Schema_Builtin | Size: 0x1
			GlobalTypes::CUtlStringToken m_tokLayerMatchID; // 0x37c | Schema_Atomic | Size: 0x4
			GlobalTypes::CUtlStringToken m_nSubclassID; // 0x380 | Schema_Atomic | Size: 0x4
			S2_PAD(0xc);
			int32_t m_nSimulationTick; // 0x390 | Schema_Builtin | Size: 0x4
			int32_t m_iCurrentThinkContext; // 0x394 | Schema_Builtin | Size: 0x4
			GlobalTypes::CUtlVector< client::thinkfunc_t > m_aThinkFunctions; // 0x398 | Schema_Atomic | Size: 0x18
			// char  m_aThinkFunctions[0x18]; // 0x398 | Schema_Atomic | Size: 0x18
			bool m_bDisabledContextThinks; // 0x3b0 | Schema_Builtin | Size: 0x1
			S2_PAD(0x3);
			float32 m_flAnimTime; // 0x3b4 | Schema_Builtin | Size: 0x4
			float32 m_flSimulationTime; // 0x3b8 | Schema_Builtin | Size: 0x4
			uint8_t m_nSceneObjectOverrideFlags; // 0x3bc | Schema_Builtin | Size: 0x1
			bool m_bHasSuccessfullyInterpolated; // 0x3bd | Schema_Builtin | Size: 0x1
			bool m_bHasAddedVarsToInterpolation; // 0x3be | Schema_Builtin | Size: 0x1
			bool m_bRenderEvenWhenNotSuccessfullyInterpolated; // 0x3bf | Schema_Builtin | Size: 0x1
			int32_t m_nInterpolationLatchDirtyFlags[2]; // 0x3c0 | Schema_FixedArray | Size: 0x8
			uint16_t m_ListEntry[11]; // 0x3c8 | Schema_FixedArray | Size: 0x16
			S2_PAD(0x2);
			entity2::GameTime_t m_flCreateTime; // 0x3e0 | Schema_DeclaredClass | Size: 0x4
			float32 m_flSpeed; // 0x3e4 | Schema_Builtin | Size: 0x4
			uint16_t m_EntClientFlags; // 0x3e8 | Schema_Builtin | Size: 0x2
			bool m_bClientSideRagdoll; // 0x3ea | Schema_Builtin | Size: 0x1
			uint8_t m_iTeamNum; // 0x3eb | Schema_Builtin | Size: 0x1
			uint32_t m_spawnflags; // 0x3ec | Schema_Builtin | Size: 0x4
			entity2::GameTick_t m_nNextThinkTick; // 0x3f0 | Schema_DeclaredClass | Size: 0x4
			S2_PAD(0x4);
			uint32_t m_fFlags; // 0x3f8 | Schema_Builtin | Size: 0x4
			GlobalTypes::Vector m_vecAbsVelocity; // 0x3fc | Schema_Atomic | Size: 0xc
			client::CNetworkVelocityVector m_vecServerVelocity; // 0x408 | Schema_DeclaredClass | Size: 0x28
			client::CNetworkVelocityVector m_vecVelocity; // 0x430 | Schema_DeclaredClass | Size: 0x28
			S2_PAD(0xb8);
			GlobalTypes::Vector m_vecBaseVelocity; // 0x510 | Schema_Atomic | Size: 0xc
			GlobalTypes::CHandle< client::C_BaseEntity > m_hEffectEntity; // 0x51c | Schema_Atomic | Size: 0x4
			// char  m_hEffectEntity[0x4]; // 0x51c | Schema_Atomic | Size: 0x4
			GlobalTypes::CHandle< client::C_BaseEntity > m_hOwnerEntity; // 0x520 | Schema_Atomic | Size: 0x4
			// char  m_hOwnerEntity[0x4]; // 0x520 | Schema_Atomic | Size: 0x4
			client::MoveCollide_t m_MoveCollide; // 0x524 | Schema_DeclaredEnum | Size: 0x1
			client::MoveType_t m_MoveType; // 0x525 | Schema_DeclaredEnum | Size: 0x1
			client::MoveType_t m_nActualMoveType; // 0x526 | Schema_DeclaredEnum | Size: 0x1
			S2_PAD(0x1);
			float32 m_flWaterLevel; // 0x528 | Schema_Builtin | Size: 0x4
			uint32_t m_fEffects; // 0x52c | Schema_Builtin | Size: 0x4
			GlobalTypes::CHandle< client::C_BaseEntity > m_hGroundEntity; // 0x530 | Schema_Atomic | Size: 0x4
			// char  m_hGroundEntity[0x4]; // 0x530 | Schema_Atomic | Size: 0x4
			int32_t m_nGroundBodyIndex; // 0x534 | Schema_Builtin | Size: 0x4
			float32 m_flFriction; // 0x538 | Schema_Builtin | Size: 0x4
			float32 m_flElasticity; // 0x53c | Schema_Builtin | Size: 0x4
			float32 m_flGravityScale; // 0x540 | Schema_Builtin | Size: 0x4
			float32 m_flTimeScale; // 0x544 | Schema_Builtin | Size: 0x4
			bool m_bAnimatedEveryTick; // 0x548 | Schema_Builtin | Size: 0x1
			bool m_bGravityDisabled; // 0x549 | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			entity2::GameTime_t m_flNavIgnoreUntilTime; // 0x54c | Schema_DeclaredClass | Size: 0x4
			uint16_t m_hThink; // 0x550 | Schema_Builtin | Size: 0x2
			S2_PAD(0xe);
			uint8_t m_fBBoxVisFlags; // 0x560 | Schema_Builtin | Size: 0x1
			S2_PAD(0x3);
			float32 m_flActualGravityScale; // 0x564 | Schema_Builtin | Size: 0x4
			bool m_bGravityActuallyDisabled; // 0x568 | Schema_Builtin | Size: 0x1
			bool m_bPredictable; // 0x569 | Schema_Builtin | Size: 0x1
			bool m_bRenderWithViewModels; // 0x56a | Schema_Builtin | Size: 0x1
			S2_PAD(0x1);
			int32_t m_nFirstPredictableCommand; // 0x56c | Schema_Builtin | Size: 0x4
			int32_t m_nLastPredictableCommand; // 0x570 | Schema_Builtin | Size: 0x4
			GlobalTypes::CHandle< client::C_BaseEntity > m_hOldMoveParent; // 0x574 | Schema_Atomic | Size: 0x4
			// char  m_hOldMoveParent[0x4]; // 0x574 | Schema_Atomic | Size: 0x4
			particleslib::CParticleProperty m_Particles; // 0x578 | Schema_DeclaredClass | Size: 0x28
			S2_PAD(0x8);
			GlobalTypes::QAngle m_vecAngVelocity; // 0x5a8 | Schema_Atomic | Size: 0xc
			int32_t m_DataChangeEventRef; // 0x5b4 | Schema_Builtin | Size: 0x4
			GlobalTypes::CUtlVector< GlobalTypes::CEntityHandle > m_dependencies; // 0x5b8 | Schema_Atomic | Size: 0x18
			// char  m_dependencies[0x18]; // 0x5b8 | Schema_Atomic | Size: 0x18
			int32_t m_nCreationTick; // 0x5d0 | Schema_Builtin | Size: 0x4
			S2_PAD(0x9);
			bool m_bAnimTimeChanged; // 0x5dd | Schema_Builtin | Size: 0x1
			bool m_bSimulationTimeChanged; // 0x5de | Schema_Builtin | Size: 0x1
			S2_PAD(0x9);
			GlobalTypes::CUtlString m_sUniqueHammerID; // 0x5e8 | Schema_Atomic | Size: 0x8
			client::BloodType m_nBloodType; // 0x5f0 | Schema_DeclaredEnum | Size: 0x4
			S2_PAD(0x4); // End padding
		};
		static_assert(offsetof(CS2::client::C_BaseEntity, m_CBodyComponent) == 0x38, "m_CBodyComponent in C_BaseEntity should be at offset 0x38");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_NetworkTransmitComponent) == 0x40, "m_NetworkTransmitComponent in C_BaseEntity should be at offset 0x40");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nLastThinkTick) == 0x328, "m_nLastThinkTick in C_BaseEntity should be at offset 0x328");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_pGameSceneNode) == 0x330, "m_pGameSceneNode in C_BaseEntity should be at offset 0x330");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_pRenderComponent) == 0x338, "m_pRenderComponent in C_BaseEntity should be at offset 0x338");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_pCollision) == 0x340, "m_pCollision in C_BaseEntity should be at offset 0x340");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_iMaxHealth) == 0x348, "m_iMaxHealth in C_BaseEntity should be at offset 0x348");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_iHealth) == 0x34C, "m_iHealth in C_BaseEntity should be at offset 0x34C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flDamageAccumulator) == 0x350, "m_flDamageAccumulator in C_BaseEntity should be at offset 0x350");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_lifeState) == 0x354, "m_lifeState in C_BaseEntity should be at offset 0x354");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bTakesDamage) == 0x355, "m_bTakesDamage in C_BaseEntity should be at offset 0x355");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nTakeDamageFlags) == 0x358, "m_nTakeDamageFlags in C_BaseEntity should be at offset 0x358");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nPlatformType) == 0x360, "m_nPlatformType in C_BaseEntity should be at offset 0x360");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_ubInterpolationFrame) == 0x361, "m_ubInterpolationFrame in C_BaseEntity should be at offset 0x361");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hSceneObjectController) == 0x364, "m_hSceneObjectController in C_BaseEntity should be at offset 0x364");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nNoInterpolationTick) == 0x368, "m_nNoInterpolationTick in C_BaseEntity should be at offset 0x368");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nVisibilityNoInterpolationTick) == 0x36C, "m_nVisibilityNoInterpolationTick in C_BaseEntity should be at offset 0x36C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flProxyRandomValue) == 0x370, "m_flProxyRandomValue in C_BaseEntity should be at offset 0x370");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_iEFlags) == 0x374, "m_iEFlags in C_BaseEntity should be at offset 0x374");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nWaterType) == 0x378, "m_nWaterType in C_BaseEntity should be at offset 0x378");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bInterpolateEvenWithNoModel) == 0x379, "m_bInterpolateEvenWithNoModel in C_BaseEntity should be at offset 0x379");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bPredictionEligible) == 0x37A, "m_bPredictionEligible in C_BaseEntity should be at offset 0x37A");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bApplyLayerMatchIDToModel) == 0x37B, "m_bApplyLayerMatchIDToModel in C_BaseEntity should be at offset 0x37B");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_tokLayerMatchID) == 0x37C, "m_tokLayerMatchID in C_BaseEntity should be at offset 0x37C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nSubclassID) == 0x380, "m_nSubclassID in C_BaseEntity should be at offset 0x380");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nSimulationTick) == 0x390, "m_nSimulationTick in C_BaseEntity should be at offset 0x390");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_iCurrentThinkContext) == 0x394, "m_iCurrentThinkContext in C_BaseEntity should be at offset 0x394");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_aThinkFunctions) == 0x398, "m_aThinkFunctions in C_BaseEntity should be at offset 0x398");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bDisabledContextThinks) == 0x3B0, "m_bDisabledContextThinks in C_BaseEntity should be at offset 0x3B0");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flAnimTime) == 0x3B4, "m_flAnimTime in C_BaseEntity should be at offset 0x3B4");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flSimulationTime) == 0x3B8, "m_flSimulationTime in C_BaseEntity should be at offset 0x3B8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nSceneObjectOverrideFlags) == 0x3BC, "m_nSceneObjectOverrideFlags in C_BaseEntity should be at offset 0x3BC");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bHasSuccessfullyInterpolated) == 0x3BD, "m_bHasSuccessfullyInterpolated in C_BaseEntity should be at offset 0x3BD");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bHasAddedVarsToInterpolation) == 0x3BE, "m_bHasAddedVarsToInterpolation in C_BaseEntity should be at offset 0x3BE");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bRenderEvenWhenNotSuccessfullyInterpolated) == 0x3BF, "m_bRenderEvenWhenNotSuccessfullyInterpolated in C_BaseEntity should be at offset 0x3BF");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nInterpolationLatchDirtyFlags) == 0x3C0, "m_nInterpolationLatchDirtyFlags in C_BaseEntity should be at offset 0x3C0");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_ListEntry) == 0x3C8, "m_ListEntry in C_BaseEntity should be at offset 0x3C8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flCreateTime) == 0x3E0, "m_flCreateTime in C_BaseEntity should be at offset 0x3E0");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flSpeed) == 0x3E4, "m_flSpeed in C_BaseEntity should be at offset 0x3E4");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_EntClientFlags) == 0x3E8, "m_EntClientFlags in C_BaseEntity should be at offset 0x3E8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bClientSideRagdoll) == 0x3EA, "m_bClientSideRagdoll in C_BaseEntity should be at offset 0x3EA");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_iTeamNum) == 0x3EB, "m_iTeamNum in C_BaseEntity should be at offset 0x3EB");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_spawnflags) == 0x3EC, "m_spawnflags in C_BaseEntity should be at offset 0x3EC");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nNextThinkTick) == 0x3F0, "m_nNextThinkTick in C_BaseEntity should be at offset 0x3F0");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_fFlags) == 0x3F8, "m_fFlags in C_BaseEntity should be at offset 0x3F8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_vecAbsVelocity) == 0x3FC, "m_vecAbsVelocity in C_BaseEntity should be at offset 0x3FC");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_vecServerVelocity) == 0x408, "m_vecServerVelocity in C_BaseEntity should be at offset 0x408");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_vecVelocity) == 0x430, "m_vecVelocity in C_BaseEntity should be at offset 0x430");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_vecBaseVelocity) == 0x510, "m_vecBaseVelocity in C_BaseEntity should be at offset 0x510");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hEffectEntity) == 0x51C, "m_hEffectEntity in C_BaseEntity should be at offset 0x51C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hOwnerEntity) == 0x520, "m_hOwnerEntity in C_BaseEntity should be at offset 0x520");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_MoveCollide) == 0x524, "m_MoveCollide in C_BaseEntity should be at offset 0x524");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_MoveType) == 0x525, "m_MoveType in C_BaseEntity should be at offset 0x525");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nActualMoveType) == 0x526, "m_nActualMoveType in C_BaseEntity should be at offset 0x526");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flWaterLevel) == 0x528, "m_flWaterLevel in C_BaseEntity should be at offset 0x528");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_fEffects) == 0x52C, "m_fEffects in C_BaseEntity should be at offset 0x52C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hGroundEntity) == 0x530, "m_hGroundEntity in C_BaseEntity should be at offset 0x530");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nGroundBodyIndex) == 0x534, "m_nGroundBodyIndex in C_BaseEntity should be at offset 0x534");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flFriction) == 0x538, "m_flFriction in C_BaseEntity should be at offset 0x538");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flElasticity) == 0x53C, "m_flElasticity in C_BaseEntity should be at offset 0x53C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flGravityScale) == 0x540, "m_flGravityScale in C_BaseEntity should be at offset 0x540");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flTimeScale) == 0x544, "m_flTimeScale in C_BaseEntity should be at offset 0x544");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bAnimatedEveryTick) == 0x548, "m_bAnimatedEveryTick in C_BaseEntity should be at offset 0x548");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bGravityDisabled) == 0x549, "m_bGravityDisabled in C_BaseEntity should be at offset 0x549");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flNavIgnoreUntilTime) == 0x54C, "m_flNavIgnoreUntilTime in C_BaseEntity should be at offset 0x54C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hThink) == 0x550, "m_hThink in C_BaseEntity should be at offset 0x550");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_fBBoxVisFlags) == 0x560, "m_fBBoxVisFlags in C_BaseEntity should be at offset 0x560");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_flActualGravityScale) == 0x564, "m_flActualGravityScale in C_BaseEntity should be at offset 0x564");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bGravityActuallyDisabled) == 0x568, "m_bGravityActuallyDisabled in C_BaseEntity should be at offset 0x568");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bPredictable) == 0x569, "m_bPredictable in C_BaseEntity should be at offset 0x569");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bRenderWithViewModels) == 0x56A, "m_bRenderWithViewModels in C_BaseEntity should be at offset 0x56A");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nFirstPredictableCommand) == 0x56C, "m_nFirstPredictableCommand in C_BaseEntity should be at offset 0x56C");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nLastPredictableCommand) == 0x570, "m_nLastPredictableCommand in C_BaseEntity should be at offset 0x570");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_hOldMoveParent) == 0x574, "m_hOldMoveParent in C_BaseEntity should be at offset 0x574");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_Particles) == 0x578, "m_Particles in C_BaseEntity should be at offset 0x578");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_vecAngVelocity) == 0x5A8, "m_vecAngVelocity in C_BaseEntity should be at offset 0x5A8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_DataChangeEventRef) == 0x5B4, "m_DataChangeEventRef in C_BaseEntity should be at offset 0x5B4");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_dependencies) == 0x5B8, "m_dependencies in C_BaseEntity should be at offset 0x5B8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nCreationTick) == 0x5D0, "m_nCreationTick in C_BaseEntity should be at offset 0x5D0");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bAnimTimeChanged) == 0x5DD, "m_bAnimTimeChanged in C_BaseEntity should be at offset 0x5DD");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_bSimulationTimeChanged) == 0x5DE, "m_bSimulationTimeChanged in C_BaseEntity should be at offset 0x5DE");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_sUniqueHammerID) == 0x5E8, "m_sUniqueHammerID in C_BaseEntity should be at offset 0x5E8");
		static_assert(offsetof(CS2::client::C_BaseEntity, m_nBloodType) == 0x5F0, "m_nBloodType in C_BaseEntity should be at offset 0x5F0");
		static_assert(sizeof(CS2::client::C_BaseEntity) == 0x5F8, "C_BaseEntity size should be 0x5F8");
	}
}
