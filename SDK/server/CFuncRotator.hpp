// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/server/CBaseModelEntity.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>
#include <SDK/server/Rotate_t.hpp>
#include <SDK/server/RotatorTargetSpace_t.hpp>



namespace CS2 {
	namespace server {
		class RotatorHistoryEntry_t;
		class RotatorQueueEntry_t;
	}
}
namespace CS2 {
	namespace server {
		class CFuncRotator : public CS2::server::CBaseModelEntity {
		public:
			// server::CHandle< server::CBaseEntity > m_hRotatorTarget; // 0x7d8 | Schema_Atomic | Size: 0x4
			char  m_hRotatorTarget[0x4]; // 0x7d8 | Schema_Atomic | Size: 0x4
			bool m_bIsRotating; // 0x7dc | Schema_Builtin | Size: 0x1
			bool m_bIsReversing; // 0x7dd | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			float32 m_flTimeToReachMaxSpeed; // 0x7e0 | Schema_Builtin | Size: 0x4
			float32 m_flTimeToReachZeroSpeed; // 0x7e4 | Schema_Builtin | Size: 0x4
			float32 m_flDistanceAlongArcTraveled; // 0x7e8 | Schema_Builtin | Size: 0x4
			float32 m_flTimeToWaitOscillate; // 0x7ec | Schema_Builtin | Size: 0x4
			entity2::GameTime_t m_flTimeRotationStart; // 0x7f0 | Schema_DeclaredClass | Size: 0x4
			S2_PAD(0xc);
			GlobalTypes::Quaternion m_qLSPrevChange; // 0x800 | Schema_Atomic | Size: 0x10
			GlobalTypes::Quaternion m_qWSPrev; // 0x810 | Schema_Atomic | Size: 0x10
			GlobalTypes::Quaternion m_qWSInit; // 0x820 | Schema_Atomic | Size: 0x10
			GlobalTypes::Quaternion m_qLSInit; // 0x830 | Schema_Atomic | Size: 0x10
			GlobalTypes::Quaternion m_qLSOrientation; // 0x840 | Schema_Atomic | Size: 0x10
			entity2::CEntityIOOutput m_OnRotationStarted; // 0x850 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnRotationCompleted; // 0x878 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnOscillate; // 0x8a0 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnOscillateStartArrive; // 0x8c8 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnOscillateStartDepart; // 0x8f0 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnOscillateEndArrive; // 0x918 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnOscillateEndDepart; // 0x940 | Schema_DeclaredClass | Size: 0x28
			bool m_bOscillateDepart; // 0x968 | Schema_Builtin | Size: 0x1
			S2_PAD(0x3);
			int32_t m_nOscillateCount; // 0x96c | Schema_Builtin | Size: 0x4
			server::Rotate_t m_eRotateType; // 0x970 | Schema_DeclaredEnum | Size: 0x4
			server::Rotate_t m_ePrevRotateType; // 0x974 | Schema_DeclaredEnum | Size: 0x4
			bool m_bHasTargetOverride; // 0x978 | Schema_Builtin | Size: 0x1
			S2_PAD(0x7);
			GlobalTypes::Quaternion m_qOrientationOverride; // 0x980 | Schema_Atomic | Size: 0x10
			server::RotatorTargetSpace_t m_eSpaceOverride; // 0x990 | Schema_DeclaredEnum | Size: 0x4
			GlobalTypes::QAngle m_qAngularVelocity; // 0x994 | Schema_Atomic | Size: 0xc
			GlobalTypes::Vector m_vLookAtForcedUp; // 0x9a0 | Schema_Atomic | Size: 0xc
			S2_PAD(0x4);
			GlobalTypes::CUtlSymbolLarge m_strRotatorTarget; // 0x9b0 | Schema_Atomic | Size: 0x8
			bool m_bRecordHistory; // 0x9b8 | Schema_Builtin | Size: 0x1
			S2_PAD(0x7);
			GlobalTypes::CUtlVector< server::RotatorHistoryEntry_t > m_vecRotatorHistory; // 0x9c0 | Schema_Atomic | Size: 0x18
			// char  m_vecRotatorHistory[0x18]; // 0x9c0 | Schema_Atomic | Size: 0x18
			// GlobalTypes::CUtlVector< server::RotatorHistoryEntry_t > m_vecRotatorHistory; // 0x9c0 | Schema_Atomic | Size: 0x18
			bool m_bReturningToPreviousOrientation; // 0x9d8 | Schema_Builtin | Size: 0x1
			S2_PAD(0x7);
			GlobalTypes::CUtlVector< server::RotatorQueueEntry_t > m_vecRotatorQueue; // 0x9e0 | Schema_Atomic | Size: 0x18
			// char  m_vecRotatorQueue[0x18]; // 0x9e0 | Schema_Atomic | Size: 0x18
			// GlobalTypes::CUtlVector< server::RotatorQueueEntry_t > m_vecRotatorQueue; // 0x9e0 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlVector< server::RotatorHistoryEntry_t > m_vecRotatorQueueHistory; // 0x9f8 | Schema_Atomic | Size: 0x18
			// char  m_vecRotatorQueueHistory[0x18]; // 0x9f8 | Schema_Atomic | Size: 0x18
			// GlobalTypes::CUtlVector< server::RotatorHistoryEntry_t > m_vecRotatorQueueHistory; // 0x9f8 | Schema_Atomic | Size: 0x18
		};
		static_assert(offsetof(CS2::server::CFuncRotator, m_hRotatorTarget) == 0x7D8, "m_hRotatorTarget in CFuncRotator should be at offset 0x7D8");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bIsRotating) == 0x7DC, "m_bIsRotating in CFuncRotator should be at offset 0x7DC");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bIsReversing) == 0x7DD, "m_bIsReversing in CFuncRotator should be at offset 0x7DD");
		static_assert(offsetof(CS2::server::CFuncRotator, m_flTimeToReachMaxSpeed) == 0x7E0, "m_flTimeToReachMaxSpeed in CFuncRotator should be at offset 0x7E0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_flTimeToReachZeroSpeed) == 0x7E4, "m_flTimeToReachZeroSpeed in CFuncRotator should be at offset 0x7E4");
		static_assert(offsetof(CS2::server::CFuncRotator, m_flDistanceAlongArcTraveled) == 0x7E8, "m_flDistanceAlongArcTraveled in CFuncRotator should be at offset 0x7E8");
		static_assert(offsetof(CS2::server::CFuncRotator, m_flTimeToWaitOscillate) == 0x7EC, "m_flTimeToWaitOscillate in CFuncRotator should be at offset 0x7EC");
		static_assert(offsetof(CS2::server::CFuncRotator, m_flTimeRotationStart) == 0x7F0, "m_flTimeRotationStart in CFuncRotator should be at offset 0x7F0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qLSPrevChange) == 0x800, "m_qLSPrevChange in CFuncRotator should be at offset 0x800");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qWSPrev) == 0x810, "m_qWSPrev in CFuncRotator should be at offset 0x810");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qWSInit) == 0x820, "m_qWSInit in CFuncRotator should be at offset 0x820");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qLSInit) == 0x830, "m_qLSInit in CFuncRotator should be at offset 0x830");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qLSOrientation) == 0x840, "m_qLSOrientation in CFuncRotator should be at offset 0x840");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnRotationStarted) == 0x850, "m_OnRotationStarted in CFuncRotator should be at offset 0x850");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnRotationCompleted) == 0x878, "m_OnRotationCompleted in CFuncRotator should be at offset 0x878");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnOscillate) == 0x8A0, "m_OnOscillate in CFuncRotator should be at offset 0x8A0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnOscillateStartArrive) == 0x8C8, "m_OnOscillateStartArrive in CFuncRotator should be at offset 0x8C8");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnOscillateStartDepart) == 0x8F0, "m_OnOscillateStartDepart in CFuncRotator should be at offset 0x8F0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnOscillateEndArrive) == 0x918, "m_OnOscillateEndArrive in CFuncRotator should be at offset 0x918");
		static_assert(offsetof(CS2::server::CFuncRotator, m_OnOscillateEndDepart) == 0x940, "m_OnOscillateEndDepart in CFuncRotator should be at offset 0x940");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bOscillateDepart) == 0x968, "m_bOscillateDepart in CFuncRotator should be at offset 0x968");
		static_assert(offsetof(CS2::server::CFuncRotator, m_nOscillateCount) == 0x96C, "m_nOscillateCount in CFuncRotator should be at offset 0x96C");
		static_assert(offsetof(CS2::server::CFuncRotator, m_eRotateType) == 0x970, "m_eRotateType in CFuncRotator should be at offset 0x970");
		static_assert(offsetof(CS2::server::CFuncRotator, m_ePrevRotateType) == 0x974, "m_ePrevRotateType in CFuncRotator should be at offset 0x974");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bHasTargetOverride) == 0x978, "m_bHasTargetOverride in CFuncRotator should be at offset 0x978");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qOrientationOverride) == 0x980, "m_qOrientationOverride in CFuncRotator should be at offset 0x980");
		static_assert(offsetof(CS2::server::CFuncRotator, m_eSpaceOverride) == 0x990, "m_eSpaceOverride in CFuncRotator should be at offset 0x990");
		static_assert(offsetof(CS2::server::CFuncRotator, m_qAngularVelocity) == 0x994, "m_qAngularVelocity in CFuncRotator should be at offset 0x994");
		static_assert(offsetof(CS2::server::CFuncRotator, m_vLookAtForcedUp) == 0x9A0, "m_vLookAtForcedUp in CFuncRotator should be at offset 0x9A0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_strRotatorTarget) == 0x9B0, "m_strRotatorTarget in CFuncRotator should be at offset 0x9B0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bRecordHistory) == 0x9B8, "m_bRecordHistory in CFuncRotator should be at offset 0x9B8");
		static_assert(offsetof(CS2::server::CFuncRotator, m_vecRotatorHistory) == 0x9C0, "m_vecRotatorHistory in CFuncRotator should be at offset 0x9C0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_bReturningToPreviousOrientation) == 0x9D8, "m_bReturningToPreviousOrientation in CFuncRotator should be at offset 0x9D8");
		static_assert(offsetof(CS2::server::CFuncRotator, m_vecRotatorQueue) == 0x9E0, "m_vecRotatorQueue in CFuncRotator should be at offset 0x9E0");
		static_assert(offsetof(CS2::server::CFuncRotator, m_vecRotatorQueueHistory) == 0x9F8, "m_vecRotatorQueueHistory in CFuncRotator should be at offset 0x9F8");
		static_assert(sizeof(CS2::server::CFuncRotator) == 0xA10, "CFuncRotator size should be 0xA10");
	}
}
