// generated - do not edit!
// generated by @xsip cs2 schema generator

#pragma once

#ifndef CUSTOM_GLOBAL_TYPES
	#include <SDK/GlobalTypes.hpp>
#else
	#include <Custom/GlobalTypes.hpp>
#endif


#include <SDK/entity2/CEntityInstance.hpp>
#include <SDK/client/CNetworkTransmitComponent.hpp>
#include <SDK/entity2/GameTick_t.hpp>
#include <SDK/client/TakeDamageFlags_t.hpp>
#include <SDK/client/EntityPlatformTypes_t.hpp>
#include <SDK/client/MoveCollide_t.hpp>
#include <SDK/client/MoveType_t.hpp>
#include <SDK/entity2/GameTime_t.hpp>
#include <SDK/entity2/CEntityIOOutput.hpp>
#include <SDK/client/CNetworkVelocityVector.hpp>
#include <SDK/client/BloodType.hpp>



namespace CS2 {
	namespace server {
		class CBodyComponent;
		class ResponseContext_t;
		class CCollisionProperty;
		class CPulseGraphInstance_ServerEntity;
	}
	namespace client {
		class thinkfunc_t;
	}
}
namespace CS2 {
	namespace server {
		class CBaseEntity : public CS2::entity2::CEntityInstance {
		public:
			server::CBodyComponent* m_CBodyComponent; // 0x38 | Schema_Ptr | Size: 0x8
			client::CNetworkTransmitComponent m_NetworkTransmitComponent; // 0x40 | Schema_DeclaredClass | Size: 0x1c8
			S2_PAD(0x40);
			GlobalTypes::CUtlVector< client::thinkfunc_t > m_aThinkFunctions; // 0x248 | Schema_Atomic | Size: 0x18
			// char  m_aThinkFunctions[0x18]; // 0x248 | Schema_Atomic | Size: 0x18
			// GlobalTypes::CUtlVector< client::thinkfunc_t > m_aThinkFunctions; // 0x248 | Schema_Atomic | Size: 0x18
			int32_t m_iCurrentThinkContext; // 0x260 | Schema_Builtin | Size: 0x4
			entity2::GameTick_t m_nLastThinkTick; // 0x264 | Schema_DeclaredClass | Size: 0x4
			bool m_bDisabledContextThinks; // 0x268 | Schema_Builtin | Size: 0x1
			S2_PAD(0xf);
			// GlobalTypes::CTypedBitVec< 64 > m_isSteadyState; // 0x278 | Schema_Atomic | Size: 0x8
			char  m_isSteadyState[0x8]; // 0x278 | Schema_Atomic | Size: 0x8
			float32 m_lastNetworkChange; // 0x280 | Schema_Builtin | Size: 0x4
			S2_PAD(0xc);
			GlobalTypes::CUtlVector< server::ResponseContext_t > m_ResponseContexts; // 0x290 | Schema_Atomic | Size: 0x18
			// char  m_ResponseContexts[0x18]; // 0x290 | Schema_Atomic | Size: 0x18
			// GlobalTypes::CUtlVector< server::ResponseContext_t > m_ResponseContexts; // 0x290 | Schema_Atomic | Size: 0x18
			GlobalTypes::CUtlSymbolLarge m_iszResponseContext; // 0x2a8 | Schema_Atomic | Size: 0x8
			S2_PAD(0x20);
			int32_t m_iHealth; // 0x2d0 | Schema_Builtin | Size: 0x4
			int32_t m_iMaxHealth; // 0x2d4 | Schema_Builtin | Size: 0x4
			uint8_t m_lifeState; // 0x2d8 | Schema_Builtin | Size: 0x1
			S2_PAD(0x3);
			float32 m_flDamageAccumulator; // 0x2dc | Schema_Builtin | Size: 0x4
			bool m_bTakesDamage; // 0x2e0 | Schema_Builtin | Size: 0x1
			S2_PAD(0x7);
			client::TakeDamageFlags_t m_nTakeDamageFlags; // 0x2e8 | Schema_DeclaredEnum | Size: 0x8
			client::EntityPlatformTypes_t m_nPlatformType; // 0x2f0 | Schema_DeclaredEnum | Size: 0x1
			S2_PAD(0x1);
			client::MoveCollide_t m_MoveCollide; // 0x2f2 | Schema_DeclaredEnum | Size: 0x1
			client::MoveType_t m_MoveType; // 0x2f3 | Schema_DeclaredEnum | Size: 0x1
			client::MoveType_t m_nActualMoveType; // 0x2f4 | Schema_DeclaredEnum | Size: 0x1
			uint8_t m_nWaterTouch; // 0x2f5 | Schema_Builtin | Size: 0x1
			uint8_t m_nSlimeTouch; // 0x2f6 | Schema_Builtin | Size: 0x1
			bool m_bRestoreInHierarchy; // 0x2f7 | Schema_Builtin | Size: 0x1
			GlobalTypes::CUtlSymbolLarge m_target; // 0x2f8 | Schema_Atomic | Size: 0x8
			// server::CHandle< server::CBaseFilter > m_hDamageFilter; // 0x300 | Schema_Atomic | Size: 0x4
			char  m_hDamageFilter[0x4]; // 0x300 | Schema_Atomic | Size: 0x4
			S2_PAD(0x4);
			GlobalTypes::CUtlSymbolLarge m_iszDamageFilterName; // 0x308 | Schema_Atomic | Size: 0x8
			float32 m_flMoveDoneTime; // 0x310 | Schema_Builtin | Size: 0x4
			GlobalTypes::CUtlStringToken m_nSubclassID; // 0x314 | Schema_Atomic | Size: 0x4
			S2_PAD(0x8);
			float32 m_flAnimTime; // 0x320 | Schema_Builtin | Size: 0x4
			float32 m_flSimulationTime; // 0x324 | Schema_Builtin | Size: 0x4
			entity2::GameTime_t m_flCreateTime; // 0x328 | Schema_DeclaredClass | Size: 0x4
			bool m_bClientSideRagdoll; // 0x32c | Schema_Builtin | Size: 0x1
			uint8_t m_ubInterpolationFrame; // 0x32d | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			GlobalTypes::Vector m_vPrevVPhysicsUpdatePos; // 0x330 | Schema_Atomic | Size: 0xc
			uint8_t m_iTeamNum; // 0x33c | Schema_Builtin | Size: 0x1
			S2_PAD(0x3);
			GlobalTypes::CUtlSymbolLarge m_iGlobalname; // 0x340 | Schema_Atomic | Size: 0x8
			int32_t m_iSentToClients; // 0x348 | Schema_Builtin | Size: 0x4
			float32 m_flSpeed; // 0x34c | Schema_Builtin | Size: 0x4
			GlobalTypes::CUtlString m_sUniqueHammerID; // 0x350 | Schema_Atomic | Size: 0x8
			uint32_t m_spawnflags; // 0x358 | Schema_Builtin | Size: 0x4
			entity2::GameTick_t m_nNextThinkTick; // 0x35c | Schema_DeclaredClass | Size: 0x4
			int32_t m_nSimulationTick; // 0x360 | Schema_Builtin | Size: 0x4
			S2_PAD(0x4);
			entity2::CEntityIOOutput m_OnKilled; // 0x368 | Schema_DeclaredClass | Size: 0x28
			uint32_t m_fFlags; // 0x390 | Schema_Builtin | Size: 0x4
			GlobalTypes::Vector m_vecAbsVelocity; // 0x394 | Schema_Atomic | Size: 0xc
			client::CNetworkVelocityVector m_vecVelocity; // 0x3a0 | Schema_DeclaredClass | Size: 0x28
			S2_PAD(0x8);
			GlobalTypes::Vector m_vecBaseVelocity; // 0x3d0 | Schema_Atomic | Size: 0xc
			int32_t m_nPushEnumCount; // 0x3dc | Schema_Builtin | Size: 0x4
			server::CCollisionProperty* m_pCollision; // 0x3e0 | Schema_Ptr | Size: 0x8
			// server::CHandle< server::CBaseEntity > m_hEffectEntity; // 0x3e8 | Schema_Atomic | Size: 0x4
			char  m_hEffectEntity[0x4]; // 0x3e8 | Schema_Atomic | Size: 0x4
			// server::CHandle< server::CBaseEntity > m_hOwnerEntity; // 0x3ec | Schema_Atomic | Size: 0x4
			char  m_hOwnerEntity[0x4]; // 0x3ec | Schema_Atomic | Size: 0x4
			uint32_t m_fEffects; // 0x3f0 | Schema_Builtin | Size: 0x4
			// server::CHandle< server::CBaseEntity > m_hGroundEntity; // 0x3f4 | Schema_Atomic | Size: 0x4
			char  m_hGroundEntity[0x4]; // 0x3f4 | Schema_Atomic | Size: 0x4
			int32_t m_nGroundBodyIndex; // 0x3f8 | Schema_Builtin | Size: 0x4
			float32 m_flFriction; // 0x3fc | Schema_Builtin | Size: 0x4
			float32 m_flElasticity; // 0x400 | Schema_Builtin | Size: 0x4
			float32 m_flGravityScale; // 0x404 | Schema_Builtin | Size: 0x4
			float32 m_flTimeScale; // 0x408 | Schema_Builtin | Size: 0x4
			float32 m_flWaterLevel; // 0x40c | Schema_Builtin | Size: 0x4
			bool m_bGravityDisabled; // 0x410 | Schema_Builtin | Size: 0x1
			bool m_bAnimatedEveryTick; // 0x411 | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			float32 m_flActualGravityScale; // 0x414 | Schema_Builtin | Size: 0x4
			bool m_bGravityActuallyDisabled; // 0x418 | Schema_Builtin | Size: 0x1
			bool m_bDisableLowViolence; // 0x419 | Schema_Builtin | Size: 0x1
			uint8_t m_nWaterType; // 0x41a | Schema_Builtin | Size: 0x1
			S2_PAD(0x1);
			int32_t m_iEFlags; // 0x41c | Schema_Builtin | Size: 0x4
			entity2::CEntityIOOutput m_OnUser1; // 0x420 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnUser2; // 0x448 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnUser3; // 0x470 | Schema_DeclaredClass | Size: 0x28
			entity2::CEntityIOOutput m_OnUser4; // 0x498 | Schema_DeclaredClass | Size: 0x28
			int32_t m_iInitialTeamNum; // 0x4c0 | Schema_Builtin | Size: 0x4
			entity2::GameTime_t m_flNavIgnoreUntilTime; // 0x4c4 | Schema_DeclaredClass | Size: 0x4
			GlobalTypes::QAngle m_vecAngVelocity; // 0x4c8 | Schema_Atomic | Size: 0xc
			bool m_bNetworkQuantizeOriginAndAngles; // 0x4d4 | Schema_Builtin | Size: 0x1
			bool m_bLagCompensate; // 0x4d5 | Schema_Builtin | Size: 0x1
			S2_PAD(0x2);
			// server::CHandle< server::CBaseEntity > m_pBlocker; // 0x4d8 | Schema_Atomic | Size: 0x4
			char  m_pBlocker[0x4]; // 0x4d8 | Schema_Atomic | Size: 0x4
			float32 m_flLocalTime; // 0x4dc | Schema_Builtin | Size: 0x4
			float32 m_flVPhysicsUpdateLocalTime; // 0x4e0 | Schema_Builtin | Size: 0x4
			client::BloodType m_nBloodType; // 0x4e4 | Schema_DeclaredEnum | Size: 0x4
			server::CPulseGraphInstance_ServerEntity* m_pPulseGraphInstance; // 0x4e8 | Schema_Ptr | Size: 0x8
		};
		static_assert(offsetof(CS2::server::CBaseEntity, m_CBodyComponent) == 0x38, "m_CBodyComponent in CBaseEntity should be at offset 0x38");
		static_assert(offsetof(CS2::server::CBaseEntity, m_NetworkTransmitComponent) == 0x40, "m_NetworkTransmitComponent in CBaseEntity should be at offset 0x40");
		static_assert(offsetof(CS2::server::CBaseEntity, m_aThinkFunctions) == 0x248, "m_aThinkFunctions in CBaseEntity should be at offset 0x248");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iCurrentThinkContext) == 0x260, "m_iCurrentThinkContext in CBaseEntity should be at offset 0x260");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nLastThinkTick) == 0x264, "m_nLastThinkTick in CBaseEntity should be at offset 0x264");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bDisabledContextThinks) == 0x268, "m_bDisabledContextThinks in CBaseEntity should be at offset 0x268");
		static_assert(offsetof(CS2::server::CBaseEntity, m_isSteadyState) == 0x278, "m_isSteadyState in CBaseEntity should be at offset 0x278");
		static_assert(offsetof(CS2::server::CBaseEntity, m_lastNetworkChange) == 0x280, "m_lastNetworkChange in CBaseEntity should be at offset 0x280");
		static_assert(offsetof(CS2::server::CBaseEntity, m_ResponseContexts) == 0x290, "m_ResponseContexts in CBaseEntity should be at offset 0x290");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iszResponseContext) == 0x2A8, "m_iszResponseContext in CBaseEntity should be at offset 0x2A8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iHealth) == 0x2D0, "m_iHealth in CBaseEntity should be at offset 0x2D0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iMaxHealth) == 0x2D4, "m_iMaxHealth in CBaseEntity should be at offset 0x2D4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_lifeState) == 0x2D8, "m_lifeState in CBaseEntity should be at offset 0x2D8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flDamageAccumulator) == 0x2DC, "m_flDamageAccumulator in CBaseEntity should be at offset 0x2DC");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bTakesDamage) == 0x2E0, "m_bTakesDamage in CBaseEntity should be at offset 0x2E0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nTakeDamageFlags) == 0x2E8, "m_nTakeDamageFlags in CBaseEntity should be at offset 0x2E8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nPlatformType) == 0x2F0, "m_nPlatformType in CBaseEntity should be at offset 0x2F0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_MoveCollide) == 0x2F2, "m_MoveCollide in CBaseEntity should be at offset 0x2F2");
		static_assert(offsetof(CS2::server::CBaseEntity, m_MoveType) == 0x2F3, "m_MoveType in CBaseEntity should be at offset 0x2F3");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nActualMoveType) == 0x2F4, "m_nActualMoveType in CBaseEntity should be at offset 0x2F4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nWaterTouch) == 0x2F5, "m_nWaterTouch in CBaseEntity should be at offset 0x2F5");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nSlimeTouch) == 0x2F6, "m_nSlimeTouch in CBaseEntity should be at offset 0x2F6");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bRestoreInHierarchy) == 0x2F7, "m_bRestoreInHierarchy in CBaseEntity should be at offset 0x2F7");
		static_assert(offsetof(CS2::server::CBaseEntity, m_target) == 0x2F8, "m_target in CBaseEntity should be at offset 0x2F8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_hDamageFilter) == 0x300, "m_hDamageFilter in CBaseEntity should be at offset 0x300");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iszDamageFilterName) == 0x308, "m_iszDamageFilterName in CBaseEntity should be at offset 0x308");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flMoveDoneTime) == 0x310, "m_flMoveDoneTime in CBaseEntity should be at offset 0x310");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nSubclassID) == 0x314, "m_nSubclassID in CBaseEntity should be at offset 0x314");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flAnimTime) == 0x320, "m_flAnimTime in CBaseEntity should be at offset 0x320");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flSimulationTime) == 0x324, "m_flSimulationTime in CBaseEntity should be at offset 0x324");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flCreateTime) == 0x328, "m_flCreateTime in CBaseEntity should be at offset 0x328");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bClientSideRagdoll) == 0x32C, "m_bClientSideRagdoll in CBaseEntity should be at offset 0x32C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_ubInterpolationFrame) == 0x32D, "m_ubInterpolationFrame in CBaseEntity should be at offset 0x32D");
		static_assert(offsetof(CS2::server::CBaseEntity, m_vPrevVPhysicsUpdatePos) == 0x330, "m_vPrevVPhysicsUpdatePos in CBaseEntity should be at offset 0x330");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iTeamNum) == 0x33C, "m_iTeamNum in CBaseEntity should be at offset 0x33C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iGlobalname) == 0x340, "m_iGlobalname in CBaseEntity should be at offset 0x340");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iSentToClients) == 0x348, "m_iSentToClients in CBaseEntity should be at offset 0x348");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flSpeed) == 0x34C, "m_flSpeed in CBaseEntity should be at offset 0x34C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_sUniqueHammerID) == 0x350, "m_sUniqueHammerID in CBaseEntity should be at offset 0x350");
		static_assert(offsetof(CS2::server::CBaseEntity, m_spawnflags) == 0x358, "m_spawnflags in CBaseEntity should be at offset 0x358");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nNextThinkTick) == 0x35C, "m_nNextThinkTick in CBaseEntity should be at offset 0x35C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nSimulationTick) == 0x360, "m_nSimulationTick in CBaseEntity should be at offset 0x360");
		static_assert(offsetof(CS2::server::CBaseEntity, m_OnKilled) == 0x368, "m_OnKilled in CBaseEntity should be at offset 0x368");
		static_assert(offsetof(CS2::server::CBaseEntity, m_fFlags) == 0x390, "m_fFlags in CBaseEntity should be at offset 0x390");
		static_assert(offsetof(CS2::server::CBaseEntity, m_vecAbsVelocity) == 0x394, "m_vecAbsVelocity in CBaseEntity should be at offset 0x394");
		static_assert(offsetof(CS2::server::CBaseEntity, m_vecVelocity) == 0x3A0, "m_vecVelocity in CBaseEntity should be at offset 0x3A0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_vecBaseVelocity) == 0x3D0, "m_vecBaseVelocity in CBaseEntity should be at offset 0x3D0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nPushEnumCount) == 0x3DC, "m_nPushEnumCount in CBaseEntity should be at offset 0x3DC");
		static_assert(offsetof(CS2::server::CBaseEntity, m_pCollision) == 0x3E0, "m_pCollision in CBaseEntity should be at offset 0x3E0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_hEffectEntity) == 0x3E8, "m_hEffectEntity in CBaseEntity should be at offset 0x3E8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_hOwnerEntity) == 0x3EC, "m_hOwnerEntity in CBaseEntity should be at offset 0x3EC");
		static_assert(offsetof(CS2::server::CBaseEntity, m_fEffects) == 0x3F0, "m_fEffects in CBaseEntity should be at offset 0x3F0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_hGroundEntity) == 0x3F4, "m_hGroundEntity in CBaseEntity should be at offset 0x3F4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nGroundBodyIndex) == 0x3F8, "m_nGroundBodyIndex in CBaseEntity should be at offset 0x3F8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flFriction) == 0x3FC, "m_flFriction in CBaseEntity should be at offset 0x3FC");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flElasticity) == 0x400, "m_flElasticity in CBaseEntity should be at offset 0x400");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flGravityScale) == 0x404, "m_flGravityScale in CBaseEntity should be at offset 0x404");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flTimeScale) == 0x408, "m_flTimeScale in CBaseEntity should be at offset 0x408");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flWaterLevel) == 0x40C, "m_flWaterLevel in CBaseEntity should be at offset 0x40C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bGravityDisabled) == 0x410, "m_bGravityDisabled in CBaseEntity should be at offset 0x410");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bAnimatedEveryTick) == 0x411, "m_bAnimatedEveryTick in CBaseEntity should be at offset 0x411");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flActualGravityScale) == 0x414, "m_flActualGravityScale in CBaseEntity should be at offset 0x414");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bGravityActuallyDisabled) == 0x418, "m_bGravityActuallyDisabled in CBaseEntity should be at offset 0x418");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bDisableLowViolence) == 0x419, "m_bDisableLowViolence in CBaseEntity should be at offset 0x419");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nWaterType) == 0x41A, "m_nWaterType in CBaseEntity should be at offset 0x41A");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iEFlags) == 0x41C, "m_iEFlags in CBaseEntity should be at offset 0x41C");
		static_assert(offsetof(CS2::server::CBaseEntity, m_OnUser1) == 0x420, "m_OnUser1 in CBaseEntity should be at offset 0x420");
		static_assert(offsetof(CS2::server::CBaseEntity, m_OnUser2) == 0x448, "m_OnUser2 in CBaseEntity should be at offset 0x448");
		static_assert(offsetof(CS2::server::CBaseEntity, m_OnUser3) == 0x470, "m_OnUser3 in CBaseEntity should be at offset 0x470");
		static_assert(offsetof(CS2::server::CBaseEntity, m_OnUser4) == 0x498, "m_OnUser4 in CBaseEntity should be at offset 0x498");
		static_assert(offsetof(CS2::server::CBaseEntity, m_iInitialTeamNum) == 0x4C0, "m_iInitialTeamNum in CBaseEntity should be at offset 0x4C0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flNavIgnoreUntilTime) == 0x4C4, "m_flNavIgnoreUntilTime in CBaseEntity should be at offset 0x4C4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_vecAngVelocity) == 0x4C8, "m_vecAngVelocity in CBaseEntity should be at offset 0x4C8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bNetworkQuantizeOriginAndAngles) == 0x4D4, "m_bNetworkQuantizeOriginAndAngles in CBaseEntity should be at offset 0x4D4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_bLagCompensate) == 0x4D5, "m_bLagCompensate in CBaseEntity should be at offset 0x4D5");
		static_assert(offsetof(CS2::server::CBaseEntity, m_pBlocker) == 0x4D8, "m_pBlocker in CBaseEntity should be at offset 0x4D8");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flLocalTime) == 0x4DC, "m_flLocalTime in CBaseEntity should be at offset 0x4DC");
		static_assert(offsetof(CS2::server::CBaseEntity, m_flVPhysicsUpdateLocalTime) == 0x4E0, "m_flVPhysicsUpdateLocalTime in CBaseEntity should be at offset 0x4E0");
		static_assert(offsetof(CS2::server::CBaseEntity, m_nBloodType) == 0x4E4, "m_nBloodType in CBaseEntity should be at offset 0x4E4");
		static_assert(offsetof(CS2::server::CBaseEntity, m_pPulseGraphInstance) == 0x4E8, "m_pPulseGraphInstance in CBaseEntity should be at offset 0x4E8");
		static_assert(sizeof(CS2::server::CBaseEntity) == 0x4F0, "CBaseEntity size should be 0x4F0");
	}
}
